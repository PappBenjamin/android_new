<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/QUICK_FIX_GUIDE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/QUICK_FIX_GUIDE.md" />
              <option name="updatedContent" value="# Quick Fix &amp; Rebuild Guide&#10;&#10;## Problems Identified &amp; Fixed ✅&#10;&#10;### Problem 1: ActivityNotFoundException&#10;**Error:** `Unable to find explicit activity class LoginActivity`&#10;- **Cause:** Old APK build without updated AndroidManifest.xml&#10;- **Status:** ✅ FIXED - LoginActivity is properly declared in manifest&#10;&#10;### Problem 2: Google Sign-In Not Navigating to MainActivity&#10;**Error:** App receives successful Google auth response but doesn't navigate&#10;- **Cause:** Loading state was being reset after navigation attempt&#10;- **Status:** ✅ FIXED - Modified LoginActivity.kt to properly handle success/failure&#10;&#10;### Problem 3: Local Sign-In Returns 403 Forbidden&#10;**Error:** `{&quot;statusCode&quot;:403,&quot;message&quot;:&quot;Access denied&quot;}`&#10;- **Cause:** Account issue or invalid credentials on backend&#10;- **Status:** ⚠️ INVESTIGATE - This requires backend verification&#10;&#10;---&#10;&#10;## How to Rebuild &amp; Test&#10;&#10;### Step 1: Clean Build&#10;```bash&#10;cd /Users/macbook/Documents/III\ ev/Android\ III/android_new/MyApplication&#10;./gradlew clean build&#10;```&#10;&#10;### Step 2: Uninstall Old APK&#10;```bash&#10;adb uninstall com.firstapp.myapplication&#10;```&#10;&#10;### Step 3: Run on Emulator/Device&#10;```bash&#10;./gradlew installDebug&#10;adb shell am start -n com.firstapp.myapplication/com.firstapp.myapplication.splash.SplashActivity&#10;```&#10;&#10;Or use Android Studio:&#10;- Click &quot;Run&quot; (green play button)&#10;- Select your emulator/device&#10;- App will deploy and launch&#10;&#10;---&#10;&#10;## What to Test&#10;&#10;### ✅ Test 1: Google Sign-In Flow&#10;1. Click &quot;Login&quot; tab or start the app&#10;2. Click &quot;Google Login&quot; button&#10;3. Complete Google authentication&#10;4. **Expected:** App should navigate to MainActivity&#10;5. **Before fix:** App would hang or show loading spinner forever&#10;6. **After fix:** Should seamlessly transition to MainActivity&#10;&#10;### ✅ Test 2: Local Sign-In&#10;1. Click &quot;Login&quot; tab&#10;2. Enter email and password&#10;3. Click &quot;Login&quot; button&#10;4. **Expected:** Either login success or clear error message&#10;5. **Note:** The 403 error suggests account issue - try:&#10;   - Registering a new account&#10;   - Or using Google Sign-In (which works)&#10;&#10;### ✅ Test 3: Navigation Flow&#10;1. Start app → SplashActivity (shows logo, waits 2 seconds)&#10;2. → LoginActivity (user not authenticated) &#10;3. → After successful login → MainActivity&#10;4. **Expected:** Smooth transitions without crashes&#10;&#10;---&#10;&#10;## Files Modified&#10;- ✅ `app/src/main/java/com/firstapp/myapplication/auth/LoginActivity.kt`&#10;  - Fixed Google Sign-In navigation error handling&#10;  - Updated Color.parseColor() to use Kotlin toColorInt() extension&#10;  - Ensured loading state is only reset on error paths&#10;&#10;---&#10;&#10;## Backend 403 Error Investigation&#10;&#10;The 403 error for local sign-in (`pappbenjamin@yahoo.com`) suggests:&#10;&#10;### Check These in Your Backend:&#10;1. **Database** - Does this account exist?&#10;2. **Account Status** - Is it active/verified?&#10;3. **Credentials** - Are email/password correct?&#10;4. **Backend Logs** - What's causing the &quot;Access denied&quot; response?&#10;5. **Rate Limiting** - Is the account rate-limited after multiple failed attempts?&#10;&#10;### Quick Test:&#10;```bash&#10;# Test directly with curl&#10;curl -X POST http://10.0.2.2:8080/auth/local/signin \&#10;  -H &quot;Content-Type: application/json&quot; \&#10;  -d '{&quot;email&quot;:&quot;pappbenjamin@yahoo.com&quot;,&quot;password&quot;:&quot;radioznijo&quot;}'&#10;```&#10;&#10;---&#10;&#10;## Summary&#10;&#10;| Issue | Status | Action |&#10;|-------|--------|--------|&#10;| ActivityNotFoundException | ✅ Fixed | Rebuild app |&#10;| Google Sign-In not navigating | ✅ Fixed | Use updated LoginActivity.kt |&#10;| 403 Forbidden error | ⚠️ Investigate | Check backend account/credentials |&#10;&#10;**Next:** Rebuild the app and test Google Sign-In flow. It should now work correctly!&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/firstapp/myapplication/auth/RegisterActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/firstapp/myapplication/auth/RegisterActivity.kt" />
              <option name="originalContent" value="package com.firstapp.myapplication.auth&#10;&#10;import android.Manifest&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.content.res.ColorStateList&#10;import android.graphics.Color&#10;import android.net.Uri&#10;import android.os.Build&#10;import android.os.Bundle&#10;import android.util.Patterns&#10;import android.view.View&#10;import android.widget.Toast&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.content.ContextCompat&#10;import androidx.lifecycle.lifecycleScope&#10;import com.bumptech.glide.Glide&#10;import com.firstapp.myapplication.main.MainActivity&#10;import com.firstapp.myapplication.MyApplication&#10;import com.firstapp.myapplication.databinding.ActivityRegisterBinding&#10;import com.firstapp.myapplication.repository.AuthRepository&#10;import com.google.android.material.textfield.TextInputLayout&#10;import kotlinx.coroutines.launch&#10;&#10;class RegisterActivity : AppCompatActivity() {&#10;&#10;    private lateinit var binding: ActivityRegisterBinding&#10;    private lateinit var authRepository: AuthRepository&#10;    private lateinit var googleSignInManager: GoogleSignInManager&#10;    private var selectedImageUri: Uri? = null&#10;&#10;    companion object {&#10;        private const val GOOGLE_SIGN_IN_REQUEST_CODE = 9001&#10;    }&#10;&#10;    // Image picker launcher&#10;    private val imagePickerLauncher = registerForActivityResult(&#10;        ActivityResultContracts.GetContent()&#10;    ) { uri: Uri? -&gt;&#10;        uri?.let {&#10;            selectedImageUri = it&#10;            Glide.with(this)&#10;                .load(it)&#10;                .circleCrop()&#10;                .into(binding.ivProfileImage)&#10;        }&#10;    }&#10;&#10;    // Permission launcher&#10;    private val permissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted: Boolean -&gt;&#10;        if (isGranted) {&#10;            openImagePicker()&#10;        } else {&#10;            Toast.makeText(this, &quot;Permission denied to access photos&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        binding = ActivityRegisterBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;&#10;        // Initialize repository and Google Sign-In&#10;        val app = application as MyApplication&#10;        authRepository = AuthRepository(app.tokenManager)&#10;        googleSignInManager = GoogleSignInManager(this)&#10;&#10;        setupUI()&#10;    }&#10;&#10;    private fun setupUI() {&#10;        // Register button click&#10;        binding.btnRegisterAction.setOnClickListener {&#10;            handleRegister()&#10;        }&#10;&#10;        // Login tab click&#10;        binding.btnLogin.setOnClickListener {&#10;            // Navigate back to login activity&#10;            finish()&#10;        }&#10;&#10;        // Google register button&#10;        binding.btnGoogleRegister.setOnClickListener {&#10;            handleGoogleSignIn()&#10;        }&#10;&#10;        // Profile image click listeners&#10;        binding.ivProfileImage.setOnClickListener {&#10;            checkPermissionAndPickImage()&#10;        }&#10;&#10;        binding.tvAddPhoto.setOnClickListener {&#10;            checkPermissionAndPickImage()&#10;        }&#10;    }&#10;&#10;    private fun handleRegister() {&#10;        val username = binding.etUsername.text.toString().trim()&#10;        val email = binding.etEmail.text.toString().trim()&#10;        val password = binding.etPassword.text.toString()&#10;        val confirmPassword = binding.etConfirmPassword.text.toString()&#10;&#10;        if (validateInput(username, email, password, confirmPassword)) {&#10;            performRegister(username, email, password)&#10;        }&#10;    }&#10;&#10;    private fun validateInput(username: String, email: String, password: String, confirmPassword: String): Boolean {&#10;        var isValid = true&#10;&#10;        // Reset ALL error states first&#10;        resetFieldErrors()&#10;&#10;        // Username validation&#10;        if (username.isEmpty()) {&#10;            setFieldError(binding.tilUsername, &quot;Felhasználónév kötelező&quot;)&#10;            isValid = false&#10;        } else if (username.length &lt; 3) {&#10;            setFieldError(binding.tilUsername, &quot;Legalább 3 karakter szükséges&quot;)&#10;            isValid = false&#10;        }&#10;&#10;        // Email validation&#10;        if (email.isEmpty()) {&#10;            setFieldError(binding.tilEmail, &quot;Email cím kötelező&quot;)&#10;            isValid = false&#10;        } else if (!Patterns.EMAIL_ADDRESS.matcher(email).matches()) {&#10;            setFieldError(binding.tilEmail, &quot;Érvényes email címet adj meg&quot;)&#10;            isValid = false&#10;        }&#10;&#10;        // Password validation&#10;        if (password.isEmpty()) {&#10;            setFieldError(binding.tilPassword, &quot;Jelszó kötelező&quot;)&#10;            isValid = false&#10;        } else if (password.length &lt; 6) {&#10;            setFieldError(binding.tilPassword, &quot;Legalább 6 karakter szükséges&quot;)&#10;            isValid = false&#10;        }&#10;&#10;        // Confirm password validation&#10;        if (confirmPassword.isEmpty()) {&#10;            setFieldError(binding.tilConfirmPassword, &quot;Jelszó megerősítés kötelező&quot;)&#10;            isValid = false&#10;        } else if (password != confirmPassword) {&#10;            setFieldError(binding.tilPassword, &quot;A jelszavak nem egyeznek&quot;)&#10;            setFieldError(binding.tilConfirmPassword, &quot;A jelszavak nem egyeznek&quot;)&#10;            isValid = false&#10;        }&#10;&#10;        return isValid&#10;    }&#10;&#10;    private fun resetFieldErrors() {&#10;        // Reset all fields to normal state&#10;        resetSingleField(binding.tilUsername)&#10;        resetSingleField(binding.tilEmail)&#10;        resetSingleField(binding.tilPassword)&#10;        resetSingleField(binding.tilConfirmPassword)&#10;    }&#10;&#10;    private fun resetSingleField(textInputLayout: TextInputLayout) {&#10;        textInputLayout.error = null&#10;        textInputLayout.boxBackgroundColor = Color.parseColor(&quot;#2D3748&quot;)&#10;        textInputLayout.setBoxStrokeColorStateList(&#10;            ColorStateList.valueOf(Color.TRANSPARENT)&#10;        )&#10;    }&#10;&#10;    private fun setFieldError(textInputLayout: TextInputLayout, errorMessage: String) {&#10;        textInputLayout.error = errorMessage&#10;        // Set red background for error state&#10;        textInputLayout.boxBackgroundColor = Color.parseColor(&quot;#2D1B1F&quot;)&#10;        // Set red border&#10;        textInputLayout.setBoxStrokeColorStateList(&#10;            ColorStateList.valueOf(Color.parseColor(&quot;#EF4444&quot;))&#10;        )&#10;    }&#10;&#10;    private fun performRegister(username: String, email: String, password: String) {&#10;        // Show loading&#10;        setLoadingState(true)&#10;&#10;        lifecycleScope.launch {&#10;            try {&#10;                val result = authRepository.signUp(username, email, password)&#10;&#10;                if (result.isSuccess) {&#10;                    // Registration successful, go back to login page&#10;                    Toast.makeText(this@RegisterActivity, &quot;Registration successful! Please log in.&quot;, Toast.LENGTH_LONG).show()&#10;&#10;                    // Navigate back to LoginActivity&#10;                    finish() // This will go back to LoginActivity&#10;                } else {&#10;                    // Registration failed&#10;                    val error = result.exceptionOrNull()?.message ?: &quot;Registration failed&quot;&#10;                    Toast.makeText(this@RegisterActivity, error, Toast.LENGTH_LONG).show()&#10;                }&#10;            } catch (e: Exception) {&#10;                Toast.makeText(this@RegisterActivity, &quot;Network error: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;            } finally {&#10;                setLoadingState(false)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setLoadingState(isLoading: Boolean) {&#10;        binding.progressBar.visibility = if (isLoading) View.VISIBLE else View.GONE&#10;        binding.btnRegisterAction.isEnabled = !isLoading&#10;        binding.btnLogin.isEnabled = !isLoading&#10;        binding.btnGoogleRegister.isEnabled = !isLoading&#10;    }&#10;&#10;    private fun checkPermissionAndPickImage() {&#10;        when {&#10;            // For Android 13+ (API 33+), use READ_MEDIA_IMAGES&#10;            Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU -&gt; {&#10;                when {&#10;                    ContextCompat.checkSelfPermission(&#10;                        this,&#10;                        Manifest.permission.READ_MEDIA_IMAGES&#10;                    ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10;                        openImagePicker()&#10;                    }&#10;                    else -&gt; {&#10;                        permissionLauncher.launch(Manifest.permission.READ_MEDIA_IMAGES)&#10;                    }&#10;                }&#10;            }&#10;            // For older Android versions, use READ_EXTERNAL_STORAGE&#10;            else -&gt; {&#10;                when {&#10;                    ContextCompat.checkSelfPermission(&#10;                        this,&#10;                        Manifest.permission.READ_EXTERNAL_STORAGE&#10;                    ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10;                        openImagePicker()&#10;                    }&#10;                    else -&gt; {&#10;                        permissionLauncher.launch(Manifest.permission.READ_EXTERNAL_STORAGE)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun openImagePicker() {&#10;        imagePickerLauncher.launch(&quot;image/*&quot;)&#10;    }&#10;&#10;    private fun handleGoogleSignIn() {&#10;        setLoadingState(true)&#10;        val signInIntent = googleSignInManager.getSignInIntent()&#10;        startActivityForResult(signInIntent, GOOGLE_SIGN_IN_REQUEST_CODE)&#10;    }&#10;&#10;    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {&#10;        super.onActivityResult(requestCode, resultCode, data)&#10;&#10;        if (requestCode == GOOGLE_SIGN_IN_REQUEST_CODE) {&#10;            lifecycleScope.launch {&#10;                handleGoogleSignInResult(data)&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun handleGoogleSignInResult(data: Intent?) {&#10;        try {&#10;            val result = googleSignInManager.handleSignInResult(data)&#10;&#10;            when (result) {&#10;                is GoogleSignInResult.Success -&gt; {&#10;                    if (result.idToken != null &amp;&amp; result.email != null) {&#10;                        // Send OAuth token to backend&#10;                        performGoogleRegister(result.idToken, result.email, result.name ?: &quot;&quot;)&#10;                    } else {&#10;                        Toast.makeText(this@RegisterActivity, &quot;Failed to get user info&quot;, Toast.LENGTH_LONG).show()&#10;                        setLoadingState(false)&#10;                    }&#10;                }&#10;                is GoogleSignInResult.Error -&gt; {&#10;                    Toast.makeText(this@RegisterActivity, result.message, Toast.LENGTH_LONG).show()&#10;                    setLoadingState(false)&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Toast.makeText(this@RegisterActivity, &quot;Error: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;            setLoadingState(false)&#10;        }&#10;    }&#10;&#10;    private suspend fun performGoogleRegister(idToken: String, email: String, name: String) {&#10;        try {&#10;            // Send OAuth credentials to backend&#10;            val result = authRepository.signInWithGoogle(idToken, email, name)&#10;&#10;            if (result.isSuccess) {&#10;                // Registration successful, navigate to main activity&#10;                val intent = Intent(this@RegisterActivity, MainActivity::class.java)&#10;                intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK&#10;                startActivity(intent)&#10;                finish()&#10;            } else {&#10;                val error = result.exceptionOrNull()?.message ?: &quot;Google registration failed&quot;&#10;                Toast.makeText(this@RegisterActivity, error, Toast.LENGTH_LONG).show()&#10;            }&#10;        } catch (e: Exception) {&#10;            Toast.makeText(this@RegisterActivity, &quot;Network error: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;        } finally {&#10;            setLoadingState(false)&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.firstapp.myapplication.auth&#10;&#10;import android.Manifest&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.content.res.ColorStateList&#10;import android.graphics.Color&#10;import android.net.Uri&#10;import android.os.Build&#10;import android.os.Bundle&#10;import android.util.Patterns&#10;import android.view.View&#10;import android.widget.Toast&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.content.ContextCompat&#10;import androidx.lifecycle.lifecycleScope&#10;import com.bumptech.glide.Glide&#10;import com.firstapp.myapplication.main.MainActivity&#10;import com.firstapp.myapplication.MyApplication&#10;import com.firstapp.myapplication.databinding.ActivityRegisterBinding&#10;import com.firstapp.myapplication.repository.AuthRepository&#10;import com.google.android.material.textfield.TextInputLayout&#10;import kotlinx.coroutines.launch&#10;&#10;class RegisterActivity : AppCompatActivity() {&#10;&#10;    private lateinit var binding: ActivityRegisterBinding&#10;    private lateinit var authRepository: AuthRepository&#10;    private lateinit var googleSignInManager: GoogleSignInManager&#10;    private var selectedImageUri: Uri? = null&#10;&#10;    companion object {&#10;        private const val GOOGLE_SIGN_IN_REQUEST_CODE = 9001&#10;    }&#10;&#10;    // Image picker launcher&#10;    private val imagePickerLauncher = registerForActivityResult(&#10;        ActivityResultContracts.GetContent()&#10;    ) { uri: Uri? -&gt;&#10;        uri?.let {&#10;            selectedImageUri = it&#10;            Glide.with(this)&#10;                .load(it)&#10;                .circleCrop()&#10;                .into(binding.ivProfileImage)&#10;        }&#10;    }&#10;&#10;    // Permission launcher&#10;    private val permissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted: Boolean -&gt;&#10;        if (isGranted) {&#10;            openImagePicker()&#10;        } else {&#10;            Toast.makeText(this, &quot;Permission denied to access photos&quot;, Toast.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        binding = ActivityRegisterBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;&#10;        // Initialize repository and Google Sign-In&#10;        val app = application as MyApplication&#10;        authRepository = AuthRepository(app.tokenManager)&#10;        googleSignInManager = GoogleSignInManager(this)&#10;&#10;        setupUI()&#10;    }&#10;&#10;    private fun setupUI() {&#10;        // Register button click&#10;        binding.btnRegisterAction.setOnClickListener {&#10;            handleRegister()&#10;        }&#10;&#10;        // Login tab click&#10;        binding.btnLogin.setOnClickListener {&#10;            // Navigate back to login activity&#10;            finish()&#10;        }&#10;&#10;        // Google register button&#10;        binding.btnGoogleRegister.setOnClickListener {&#10;            handleGoogleSignIn()&#10;        }&#10;&#10;        // Profile image click listeners&#10;        binding.ivProfileImage.setOnClickListener {&#10;            checkPermissionAndPickImage()&#10;        }&#10;&#10;        binding.tvAddPhoto.setOnClickListener {&#10;            checkPermissionAndPickImage()&#10;        }&#10;    }&#10;&#10;    private fun handleRegister() {&#10;        val username = binding.etUsername.text.toString().trim()&#10;        val email = binding.etEmail.text.toString().trim()&#10;        val password = binding.etPassword.text.toString()&#10;        val confirmPassword = binding.etConfirmPassword.text.toString()&#10;&#10;        if (validateInput(username, email, password, confirmPassword)) {&#10;            performRegister(username, email, password)&#10;        }&#10;    }&#10;&#10;    private fun validateInput(username: String, email: String, password: String, confirmPassword: String): Boolean {&#10;        var isValid = true&#10;&#10;        // Reset ALL error states first&#10;        resetFieldErrors()&#10;&#10;        // Username validation&#10;        if (username.isEmpty()) {&#10;            setFieldError(binding.tilUsername, &quot;Felhasználónév kötelező&quot;)&#10;            isValid = false&#10;        } else if (username.length &lt; 3) {&#10;            setFieldError(binding.tilUsername, &quot;Legalább 3 karakter szükséges&quot;)&#10;            isValid = false&#10;        }&#10;&#10;        // Email validation&#10;        if (email.isEmpty()) {&#10;            setFieldError(binding.tilEmail, &quot;Email cím kötelező&quot;)&#10;            isValid = false&#10;        } else if (!Patterns.EMAIL_ADDRESS.matcher(email).matches()) {&#10;            setFieldError(binding.tilEmail, &quot;Érvényes email címet adj meg&quot;)&#10;            isValid = false&#10;        }&#10;&#10;        // Password validation&#10;        if (password.isEmpty()) {&#10;            setFieldError(binding.tilPassword, &quot;Jelszó kötelező&quot;)&#10;            isValid = false&#10;        } else if (password.length &lt; 6) {&#10;            setFieldError(binding.tilPassword, &quot;Legalább 6 karakter szükséges&quot;)&#10;            isValid = false&#10;        }&#10;&#10;        // Confirm password validation&#10;        if (confirmPassword.isEmpty()) {&#10;            setFieldError(binding.tilConfirmPassword, &quot;Jelszó megerősítés kötelező&quot;)&#10;            isValid = false&#10;        } else if (password != confirmPassword) {&#10;            setFieldError(binding.tilPassword, &quot;A jelszavak nem egyeznek&quot;)&#10;            setFieldError(binding.tilConfirmPassword, &quot;A jelszavak nem egyeznek&quot;)&#10;            isValid = false&#10;        }&#10;&#10;        return isValid&#10;    }&#10;&#10;    private fun resetFieldErrors() {&#10;        // Reset all fields to normal state&#10;        resetSingleField(binding.tilUsername)&#10;        resetSingleField(binding.tilEmail)&#10;        resetSingleField(binding.tilPassword)&#10;        resetSingleField(binding.tilConfirmPassword)&#10;    }&#10;&#10;    private fun resetSingleField(textInputLayout: TextInputLayout) {&#10;        textInputLayout.error = null&#10;        textInputLayout.boxBackgroundColor = Color.parseColor(&quot;#2D3748&quot;)&#10;        textInputLayout.setBoxStrokeColorStateList(&#10;            ColorStateList.valueOf(Color.TRANSPARENT)&#10;        )&#10;    }&#10;&#10;    private fun setFieldError(textInputLayout: TextInputLayout, errorMessage: String) {&#10;        textInputLayout.error = errorMessage&#10;        // Set red background for error state&#10;        textInputLayout.boxBackgroundColor = Color.parseColor(&quot;#2D1B1F&quot;)&#10;        // Set red border&#10;        textInputLayout.setBoxStrokeColorStateList(&#10;            ColorStateList.valueOf(Color.parseColor(&quot;#EF4444&quot;))&#10;        )&#10;    }&#10;&#10;    private fun performRegister(username: String, email: String, password: String) {&#10;        // Show loading&#10;        setLoadingState(true)&#10;&#10;        lifecycleScope.launch {&#10;            try {&#10;                val result = authRepository.signUp(username, email, password)&#10;&#10;                if (result.isSuccess) {&#10;                    // Registration successful, go back to login page&#10;                    Toast.makeText(this@RegisterActivity, &quot;Registration successful! Please log in.&quot;, Toast.LENGTH_LONG).show()&#10;&#10;                    // Navigate back to LoginActivity&#10;                    finish() // This will go back to LoginActivity&#10;                } else {&#10;                    // Registration failed&#10;                    val error = result.exceptionOrNull()?.message ?: &quot;Registration failed&quot;&#10;                    Toast.makeText(this@RegisterActivity, error, Toast.LENGTH_LONG).show()&#10;                }&#10;            } catch (e: Exception) {&#10;                Toast.makeText(this@RegisterActivity, &quot;Network error: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;            } finally {&#10;                setLoadingState(false)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setLoadingState(isLoading: Boolean) {&#10;        binding.progressBar.visibility = if (isLoading) View.VISIBLE else View.GONE&#10;        binding.btnRegisterAction.isEnabled = !isLoading&#10;        binding.btnLogin.isEnabled = !isLoading&#10;        binding.btnGoogleRegister.isEnabled = !isLoading&#10;    }&#10;&#10;    private fun checkPermissionAndPickImage() {&#10;        when {&#10;            // For Android 13+ (API 33+), use READ_MEDIA_IMAGES&#10;            Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU -&gt; {&#10;                when {&#10;                    ContextCompat.checkSelfPermission(&#10;                        this,&#10;                        Manifest.permission.READ_MEDIA_IMAGES&#10;                    ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10;                        openImagePicker()&#10;                    }&#10;                    else -&gt; {&#10;                        permissionLauncher.launch(Manifest.permission.READ_MEDIA_IMAGES)&#10;                    }&#10;                }&#10;            }&#10;            // For older Android versions, use READ_EXTERNAL_STORAGE&#10;            else -&gt; {&#10;                when {&#10;                    ContextCompat.checkSelfPermission(&#10;                        this,&#10;                        Manifest.permission.READ_EXTERNAL_STORAGE&#10;                    ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10;                        openImagePicker()&#10;                    }&#10;                    else -&gt; {&#10;                        permissionLauncher.launch(Manifest.permission.READ_EXTERNAL_STORAGE)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun openImagePicker() {&#10;        imagePickerLauncher.launch(&quot;image/*&quot;)&#10;    }&#10;&#10;    private fun handleGoogleSignIn() {&#10;        setLoadingState(true)&#10;        val signInIntent = googleSignInManager.getSignInIntent()&#10;        startActivityForResult(signInIntent, GOOGLE_SIGN_IN_REQUEST_CODE)&#10;    }&#10;&#10;    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {&#10;        super.onActivityResult(requestCode, resultCode, data)&#10;&#10;        if (requestCode == GOOGLE_SIGN_IN_REQUEST_CODE) {&#10;            lifecycleScope.launch {&#10;                handleGoogleSignInResult(data)&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun handleGoogleSignInResult(data: Intent?) {&#10;        try {&#10;            val result = googleSignInManager.handleSignInResult(data)&#10;&#10;            when (result) {&#10;                is GoogleSignInResult.Success -&gt; {&#10;                    if (result.idToken != null &amp;&amp; result.email != null) {&#10;                        // Send OAuth token to backend&#10;                        performGoogleRegister(result.idToken, result.email, result.name ?: &quot;&quot;)&#10;                    } else {&#10;                        Toast.makeText(this@RegisterActivity, &quot;Failed to get user info&quot;, Toast.LENGTH_LONG).show()&#10;                        setLoadingState(false)&#10;                    }&#10;                }&#10;                is GoogleSignInResult.Error -&gt; {&#10;                    Toast.makeText(this@RegisterActivity, result.message, Toast.LENGTH_LONG).show()&#10;                    setLoadingState(false)&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Toast.makeText(this@RegisterActivity, &quot;Error: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;            setLoadingState(false)&#10;        }&#10;    }&#10;&#10;    private suspend fun performGoogleRegister(idToken: String, email: String, name: String) {&#10;        try {&#10;            // Send OAuth credentials to backend&#10;            val result = authRepository.signInWithGoogle(idToken, email, name)&#10;&#10;            if (result.isSuccess) {&#10;                // Registration successful, navigate to main activity&#10;                val intent = Intent(this@RegisterActivity, MainActivity::class.java)&#10;                intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK&#10;                startActivity(intent)&#10;                finish()&#10;            } else {&#10;                val error = result.exceptionOrNull()?.message ?: &quot;Google registration failed&quot;&#10;                Toast.makeText(this@RegisterActivity, error, Toast.LENGTH_LONG).show()&#10;            }&#10;        } catch (e: Exception) {&#10;            Toast.makeText(this@RegisterActivity, &quot;Network error: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;        } finally {&#10;            setLoadingState(false)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>